// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/pdeguing/empire-and-foundation/ent/timer"
)

// Timer is the model entity for the Timer schema.
type Timer struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Action holds the value of the "action" field.
	Action timer.Action `json:"action,omitempty"`
	// Group holds the value of the "group" field.
	Group timer.Group `json:"group,omitempty"`
	// EndTime holds the value of the "end_time" field.
	EndTime time.Time `json:"end_time,omitempty"`
}

// FromRows scans the sql response data into Timer.
func (t *Timer) FromRows(rows *sql.Rows) error {
	var scant struct {
		ID      int
		Action  sql.NullString
		Group   sql.NullString
		EndTime sql.NullTime
	}
	// the order here should be the same as in the `timer.Columns`.
	if err := rows.Scan(
		&scant.ID,
		&scant.Action,
		&scant.Group,
		&scant.EndTime,
	); err != nil {
		return err
	}
	t.ID = scant.ID
	t.Action = timer.Action(scant.Action.String)
	t.Group = timer.Group(scant.Group.String)
	t.EndTime = scant.EndTime.Time
	return nil
}

// QueryPlanet queries the planet edge of the Timer.
func (t *Timer) QueryPlanet() *PlanetQuery {
	return (&TimerClient{t.config}).QueryPlanet(t)
}

// Update returns a builder for updating this Timer.
// Note that, you need to call Timer.Unwrap() before calling this method, if this Timer
// was returned from a transaction, and the transaction was committed or rolled back.
func (t *Timer) Update() *TimerUpdateOne {
	return (&TimerClient{t.config}).UpdateOne(t)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (t *Timer) Unwrap() *Timer {
	tx, ok := t.config.driver.(*txDriver)
	if !ok {
		panic("ent: Timer is not a transactional entity")
	}
	t.config.driver = tx.drv
	return t
}

// String implements the fmt.Stringer.
func (t *Timer) String() string {
	var builder strings.Builder
	builder.WriteString("Timer(")
	builder.WriteString(fmt.Sprintf("id=%v", t.ID))
	builder.WriteString(", action=")
	builder.WriteString(fmt.Sprintf("%v", t.Action))
	builder.WriteString(", group=")
	builder.WriteString(fmt.Sprintf("%v", t.Group))
	builder.WriteString(", end_time=")
	builder.WriteString(t.EndTime.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Timers is a parsable slice of Timer.
type Timers []*Timer

// FromRows scans the sql response data into Timers.
func (t *Timers) FromRows(rows *sql.Rows) error {
	for rows.Next() {
		scant := &Timer{}
		if err := scant.FromRows(rows); err != nil {
			return err
		}
		*t = append(*t, scant)
	}
	return nil
}

func (t Timers) config(cfg config) {
	for _i := range t {
		t[_i].config = cfg
	}
}
